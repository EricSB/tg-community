/*! \page howtos Howtos

Specific instructions on using features of \e opdis and \e libopdis.
<p>
\ref howto_cli
 - \ref howto_cli_arch
 - \ref howto_cli_disasm_opts
 - \ref howto_cli_map
<p>
\ref howto_app
 - \ref howto_app_visited
 - \ref howto_app_display
 - \ref howto_app_handler
 - \ref howto_app_resolver
 - \ref howto_app_decoder
<p>
<hr>
  
  \section howto_cli opdis
  \subsection howto_cli_arch Setting the target architecture
The supported architectures can be displayed with the \b --list-architectures
option:
\code
bash$ opdis --list-architectures
	i386
	i386:x86-64
	i8086
	i386:intel
	i386:x86-64:intel
	l1om
	l1om:intel
	plugin
Default architecture is 'i386'
\endcode
The architecture can then be passed to the \b -a option:
\code
opdis -a i386:x86-64
\endcode
<p>

  \subsection howto_cli_disasm_opts Setting disassembler options
The available disassembler options for all supported architectures can be 
displayed with the \b --list-disassembler-options option: 
\code
bash$ /opdis --list-disassembler-options

The following i386/x86-64 specific disassembler options are supported for use
with the -M switch (multiple options should be separated by commas):
  x86-64      Disassemble in 64bit mode
  i386        Disassemble in 32bit mode
  i8086       Disassemble in 16bit mode
  att         Display instruction in AT&T syntax
  intel       Display instruction in Intel syntax
  att-mnemonic
              Display instruction in AT&T mnemonic
  intel-mnemonic
              Display instruction in Intel mnemonic
  addr64      Assume 64bit address size
  addr32      Assume 32bit address size
  addr16      Assume 16bit address size
  data32      Assume 32bit data size
  data16      Assume 16bit data size
  suffix      Always display instruction suffix in AT&T syntax
\endcode
The disassembler options can then be passed to the \b -O option, delimited by
commas:
\code
opdis -O 'intel,x86-64'
\endcode
<p>
\note The message about the \b -M switch is generated by \b libopcodes and
      should be ignored.

  \subsection howto_cli_map Mapping memory regions
The general format for specifying a memory map is:
\code
[target]:offset@vma[+size]
\endcode
The \b :, \b @, and \b + characters are delimiters indicating that what follows
is an offset, a vma, or a size, respectively. These components may appear in
any order, but the \b target must always be first as it is not delimited.
Note that these values are all parsed with strtoul, and so they may appear
in any supported base (octal, decimal, or hexadecimal).
<p>
The \b target, \b size, and \b offset components are all optional. The default
value for \b target is 1, the ID of the first target. The default value for
\b offset is 0. The default value for \b size is the size of the target.
<p>
Memory maps are generally used for the following purposes:
 - to alter the VMA that appears in the disassembler output
 - to make multiple targets appear as a contiguous range of memory
 - to change the order in which targets appear in memory 
 - to mimic the OS load addresses of the target(s)
<p>
\b Examples
<p>

Map the entirety of a.out to VMA 0x400000:
\code
opdis -m @0x400000 a.out
\endcode

Map the entirety of a.out to VMA 0x400000 and the entirety of libc.so.6 to 
0x7f626a934000:
\code
opdis -m @0x400000 -m 2:0x7f626a934000 a.out /usr/lib/libc.so.6
\endcode

Map offset 0x1000 of a.out to VMA 0x401000:
\code
opdis -m :0x1000@0x401000 a.out
\endcode

Map buffer 1 to 0x400000 and offset 0x1000 of a.out to VMA 0x401000:
\code
opdis -m 1@400000 -m 2:0x1000@0x401000 -b '7f 45 4c 46 02 01 01 00 00' a.out
\endcode

Make buffer 1 and buffer 2 contiguous in memory:
\code
opdis -m 1@0 2@4 -b '2e 2e 74 50' -b '89 e1 31 d2'
\endcode

Make buffer 2 and buffer 1 contiguous in memory:
\code
opdis -m 2@0 1@4 -b '2e 2e 74 50' -b '89 e1 31 d2'
\endcode

<p>
  \section howto_app libopdis API
  \subsection howto_app_visited Enabling visited-address tracking
The default handler callback (\ref opdis_default_handler) supports tracking
of visited addresses. When the default handler encounters a VMA that has
previously been disassembled, it halts disassembly and prevents the display 
callback from being invoked. This is useful for applications that write the
instructions directly to output in their display callback.
<p>
Visited-address tracking is disabled by default in order to speed up 
disassembly, but it can be enabled by allocating an \ref opdis_vma_tree_t in
the \ref opdis_t \b visited_addr field:
\code
	o->visited_addr = opdis_vma_tree_init();
\endcode
\warning Visited-address tracking will slow disassembly down considerably. It
         is recommended that applications instead have their display callback
         store instructions in an \ref opdis_insn_tree_t and write to output
         after disassembly has finished; this has the additional benefit of
         ordering the disassembled instructions by VMA. The display 
         callback can be used in such cases to update a progress display.

<p>
  \subsection howto_app_display Writing a display callback
The display callback can be replaced with a function that takes an 
\ref opdis_insn_t and an optional argument parameter. The only restriction
is that the callback \b must duplicate the \ref opdis_insn_t (using
\ref opdis_insn_dupe) when storing it for later use.
<p>
This example adds an instruction to an \ref opdis_insn_tree_t and prints a 
status message:
\code
static void my_display( const opdis_insn_t * insn, void * arg ) {
	opdis_insn_tree_t tree = (opdis_insn_tree_t) arg;
	opdis_insn_t * i = opdis_insn_dupe( insn );

	opdis_insn_tree_add( tree, i );

	printf( "%d bytes at offset %X\n", insn->size, insn->offset );
}
\endcode
The following code demonstrates the use of this display callback:
\code
	/* allocate an insn tree which will free the insns when deleted */
	opdis_insn_tree_t tree = opdis_insn_tree_init( 1 );

	opdis_set_display( opdis, my_display, (void *) tree );
	/* ... code to operate on tree, e.g. opdis_insn_tree_foreach ... */

	opdis_insn_tree_free( tree );
\endcode

<p>
  \subsection howto_app_handler Writing a handler callback
The handler callback is used to determine if disassembly should continue after
the current instruction has been processed.
<p>
This example checks if a specific instruction mnemonic is encountered; if so,
the handler displays the instruction and halts disassembly. The default 
handler is chained in order to halt on invalid instructions.
\code
struct HANDLER_ARG { char halt_mnem[32]; opdis_t opdis; };

static int my_handler( const opdis_insn_t * insn, void * arg ) {
	struct HANDLER_ARG * harg = (struct HANDLER_ARG *) arg;

	/* halt disassembly if specified mnemonic is encountered */
	if ( (insn->status & opdis_decode_mnem) && 
	     ! strcmp(harg->halt_mnem, insn->mnemonic) ) {

		/* display instruction before halting */
		harg->opdis->display( insn, harg->opdis->display_arg );
		return 0;
	}

	/* invoke default handler to check for invalid and visited addresses */
	return opdis_default_handler( insn, harg->opdis );
}
\endcode
The following code demonstrates the use of this handler callback:
\code
	struct HANDLER_ARG handler_arg;
	strncpy( handler_arg.halt_mnem, "ret", 32 );
	handler_arg.opdis = o;
	opdis_set_handler( o, my_handler, (void *) &handler_arg );
\endcode
\note If the handler callback returns 0, the display callback will not be
      invoked for the current instruction. The handler must invoke the
      display callback itself if the instruction should be displayed before
      halting disassembly.
<p>

  \subsection howto_app_resolver Writing a resolver callback
The resolver callback is used to determine the VMA of the branch target of the
current instruction. Applications that provide an emulator or VM will need to
chain or replace this callback in order to resolve branch targets that are
stored in registers or at a memory location.
<p>
This example assumes a flat address space and returns the \b offset component
of an absolute address operand:
\code
static opdis_vma_t my_resolver( const opdis_insn_t * insn, void * arg ) {

	/* return the offset component of segment:offset operands */
	if ( (insn->status & opdis_decode_op_flags) &&
	     insn->target && insn->target->category == opdis_op_cat_absolute ) {
		return (opdis_vma_t) insn->target->value.abs.offset;
	}

	/* invoke the default resolver to handle immediate values */
	return opdis_default_resolver( insn, NULL );
}
\endcode
The following code demonstrates the use of this resolver callback:
\code
	opdis_set_resolver( o, my_resolver, NULL );
\endcode

<p>
  \subsection howto_app_decoder Writing a decoder callback
The decoder callback is used to generate an \ref opdis_insn_t from the list of
strings emitted by \b libopcodes. An incomplete decoder callback (such as
the default) will result in metadata not being generated for the instruction
(including the list of operands). Control-flow disassembly relies on this
metadata, making a functional decoder callback essential to most applications.
<p>
This example detects x86 control-flow instructions after invoking
\ref opdis_default_decoder to do the basic instruction decoding. It does not
chain either of the builtin x86 decoders, and no decoding is done for 
non-control-flow instructions.
\code
static const char * jcc_insns[] = {
	"ja", "jae", "jb", "jbe", "jc", "jcxz", "jecxz", 
	"jrcxz", "je", "jg", "jge", "jl", "jle", "jna", "jnae", "jnb", "jnbe",
	"jnc", "jne", "jng", "jnge", "jnl", "jnle", "jno", "jnp", "jns", "jnz",
	"jo", "jp", "jpe", "js", "jz"
};

static const char * call_insns[] = { "lcall", "call", "callq" };

static const char * jmp_insns[] = { "jmp", "ljmp", "jmpq" };

static const char * ret_insns[] = {
	"ret", "lret", "retq", "retf", "iret", "iretd", "iretq"
};

static void handle_target( opdis_insn_t * out, const char * item ) {
	opdis_op_t * op = out->operands[0];
	op->category = opdis_op_cat_unknown;
	op->flags = opdis_op_flag_x;
	opdis_op_set_ascii( op, item );
	out->target = out->operands[0];
}

static int decode_mnemonic( char ** items, int idx, opdis_insn_t * out ) {
	int i, num;
	const char *item = items[idx];

	/* detect JMP */
	num = (int) sizeof(jmp_insns) / sizeof(char *);
	for ( i = 0; i < num; i++ ) {
		if (! strcmp(jmp_insns[i], item) ) {
			out->category = opdis_insn_cat_cflow;
			out->flags.cflow = opdis_cflow_flag_jmp;
			handle_target( out, items[idx+1] );
			return 1;
		}
	}

	/* detect RET */
	num = (int) sizeof(ret_insns) / sizeof(char *);
	for ( i = 0; i < num; i++ ) {
		if (! strcmp(ret_insns[i], item) ) {
			out->category = opdis_insn_cat_cflow;
			out->flags.cflow = opdis_cflow_flag_ret;
			return 1;
		}
	}

	/* detect branch (call/jcc) */
	num = (int) sizeof(call_insns) / sizeof(char *);
	for ( i = 0; i < num; i++ ) {
		if (! strcmp(call_insns[i], item) ) {
			out->category = opdis_insn_cat_cflow;
			out->flags.cflow = opdis_cflow_flag_call;
			handle_target( out, items[idx+1] );
			return 1;
		}
	}
	num = (int) sizeof(jcc_insns) / sizeof(char *);
	for ( i = 0; i < num; i++ ) {
		if (! strcmp(jcc_insns[i], item) ) {
			out->category = opdis_insn_cat_cflow;
			out->flags.cflow = opdis_cflow_flag_jmpcc;
			handle_target( out, items[idx+1] );
			return 1;
		}
	}

	return 0;
}

static int my_decoder( const opdis_insn_buf_t in, opdis_insn_t * out,
		       const opdis_byte_t * buf, opdis_off_t offset,
		       opdis_vma_t vma, opdis_off_t length, void * arg ) {
	int i, rv;

	/* the default decoder fills ascii, vma, offset, size, and bytes.
	 * it sets status to opdis_decode_basic. */
	rv = opdis_default_decoder( in, out, buf, offset, vma, length, NULL );
	if (! rv ) {
		return rv;
	}

	for ( i=0; i < in->item_count; i++ ) {
		if ( decode_mnemonic( in->items, i, out ) ) {
			out->status |= (opdis_decode_mnem | opdis_decode_ops | 
					opdis_decode_mnem_flags);
			break;
		}
	}

	return rv;
}
\endcode
The following code demonstrates the use of this decoder callback:
\code
	opdis_set_decoder( o, my_decoder, NULL );
\endcode
\note While chaining of the default decoder (\ref opdis_default_decoder) is not
      required, it is strongly encouraged. The default decoder ensures that
      all instructions have their \b status, \b ascii, \b vma, \b offset, 
      \b size, and \b bytes fields set reliably.
*/
